**************
Implementation
**************

This section describes the different crawler implementation and how to use them.

Crawler
=======

Simple Classes
--------------

SimpleCrawler
^^^^^^^^^^^^^

The "simple" crawler does only the most important steps of the crawling process. At each iteration, when called, 
it navigates to a state with a **SimpleStateNavigator** and afterwards it generates a request and executes it using 
a **SimpleInteractionHandler**.

The diagram below shows the pipeline of the SimpleCrawler

.. figure:: img/SimpleCrawler_pipeline.png
    :align: center
    
    *SimpleCrawler Pipeline*

.. automodule:: scanner.Crawling.Simple.SimpleCrawler
    :members:

SimpleStateNavigator
^^^^^^^^^^^^^^^^^^^^

Generates a navigation queue to the next state. The next state is always the earliest state that is either not fully explored 
or not fully fuzzed. 

.. figure:: img/SimpleStateNavigatior_pipeline.png
    :align: center
    
    *SimpleStateNavigatior Pipeline*

.. note::

    The **SimpleStateNavigator** is not optimal in the sense that it doesn't keep track of the current state. Instead, it always 
    resets the web app and generates a new navigation queue to the selected state even when the state hasn't actually changed.
    This way it always stays on the safe side and ensures that the propper state is reached in a simple matter, with the cost of 
    some additional execution steps.

SimpleInteractionHandler
^^^^^^^^^^^^^^^^^^^^^^^^

Generates and executes requests. Additionally it is used to execute the navigational queue generated by the **StateNavigator**.

.. note::
    The ``generate()`` method interanally finds a suitable Endpoint in the current state for the next request. 

Detectors
=========

This section explains the functionality of each detector type.


Endpoint Extractor
------------------

Finds endpoints in the Response of an Interaction and extracts them.

Endpoint Detector
-----------------

Find duplicate endpoints and removes of flags them as invalid for the next modules part of the scanner's pipeline.

State Change Detector
---------------------

Detects state change in the web app caused by crawling or fuzzing.

State Detector
---------------

Detects duplicate states and collapses them into one.


Dection methods
===============

This section contains all of the detection methods and their functionality.

Basic
-----

.. automodule:: scanner.Detection.Basic.EndpointExtractor
    :members:

.. automodule:: scanner.Detection.Basic.EndpointDetector
    :members:

Clustering Based
----------------

.. note::
    
    The main idea is to use preimplented clustering algorithms from `Scikit-learn <https://scikit-learn.org/stable/modules/clustering.html>`_ 
    and `Scikit-learn-extra <https://scikit-learn-extra.readthedocs.io/en/stable/>`_ and implement detection logic around them.

.. warning::

    Currently the only clustering algorithm available is `DBSCAN <https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html>`_.
    After short evaluation peroid it appered to be best suiting and a decision was made to make it hard coded in the detectors. There is a possibility 
    that `the other clustering algorithms <https://scikit-learn.org/stable/modules/clustering.html>`_ could be optimal for specific cases. 

    Consider the option of implementing wrappers for the other algorithms and extending the Detectors with the option for algorithm selection.


To cluster data we need a set of features for a datapoint, which combined together form a cluster. To do this with html data 
we have to convert it to a more suitable representation for clustering. Our feature engineerin consist of one simple step. We 
hash the html data using a locality sensitive hashing algorithm, which allows us to use the new data as an input for the algorithms. 

The clustering based method internally can be devided into two categories:

Distance Matrix Based
^^^^^^^^^^^^^^^^^^^^^

For which a distance measure d\ :sub:`mn` between all possible hash pairs *(m,n)* is calculated and is presented as a square matrix A. 

.. math::
        A = \begin{bmatrix}
                0      & d_{12} & d_{13} & ... & d_{1n} \\
                d_{21} & 0      & d_{23} & ... & d_{2n} \\
                d_{31} & d_{32} & 0      & ... & d_{3n} \\
                .      & .      & .      & .   & .      \\
                .      & .      & .      & .   & .      \\
                .      & .      & .      & .   & .      \\
                d_{m1} & d_{m2} & d_{m3} & ... & 0 
            \end{bmatrix}

The distance matrix is then used as an input for the clustering algorithms that can be initialized with a ``metric='precomputed'`` parameter.


Hash as int vector (Hash2Vec)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Where each hash is represented as a character vector, which subsequently gets transformed into integer vector. This way we can use each character 
as a numerical feature, and apply the clustering methods directly on the hash set.

.. figure:: img/hash2vec_visualization.png
    :align: center
    
    *Hash2Vec Visualization*

.. note::

    Additionally, in the conversion step the features are normalized to values between 0 and 1.

Both categories are implemnted in the same classes and are selectable with the ``distance_type`` parameter. If given ``distance_type=None`` as input 
the detectors will use the Hash2Vec method else the distance matrix method is evoked and the give distance type is used for the matrix generation.

.. automodule:: scanner.Detection.ClusteringBased.StateChangeDetector
    :members:

.. automodule:: scanner.Detection.ClusteringBased.EndpointDetector
    :members:

.. automodule:: scanner.Detection.ClusteringBased.StateDetector
    :members:
