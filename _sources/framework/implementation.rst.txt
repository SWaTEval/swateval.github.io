**************
Implementation
**************

This section describes the different crawler implementations and how to use them. Please refer to our paper for a more detailed description of the aims of the different modules and on how they interact.

Crawlers
=========

The Crawlersâ€™ goal is to walk through the web-app and find new Endpoints.

SimpleCrawler
--------------

This basic crawler does only the most important steps of the crawling process. At each iteration, when called, it navigates to a state with a **SimpleStateNavigator** and afterwards it generates a request and executes it using a **SimpleInteractionHandler**.

The diagram below shows the pipeline of the SimpleCrawler:

.. figure:: img/SimpleCrawler_pipeline.png
    :align: center

    *SimpleCrawler Pipeline*

.. automodule:: scanner.Crawling.Simple.SimpleCrawler
    :members:

SimpleStateNavigator
---------------------

The **SimpleStateNavigator** generates a navigation queue to the next state. The next state is always the first state that is either not fully explored or not fully fuzzed.

.. figure:: img/SimpleStateNavigator_pipeline.png
    :align: center

    *SimpleStateNavigator Pipeline*

.. note::

    The **SimpleStateNavigator** doesn't keep track of the current state. Instead, it always resets the web app and generates a new navigation queue to the selected state even when the state hasn't actually changed.
    This way it always stays on the safe side and ensures that the proper state is reached in a simple matter, with the cost of
    some additional execution steps.

SimpleInteractionHandler
-------------------------

The **SimpleInteractionHandler** generates and executes requests. Additionally, it is used to execute the navigational queue generated by the **StateNavigator**.

.. note::
    The ``generate()`` method internally finds a suitable Endpoint in the current state for the next request.

Detectors
=========

This section explains the functionality of each detector type.


Endpoint Extractor
------------------

The **Endpoint Extractor** finds endpoints in the Response of an Interaction and extracts them.

Endpoint Detector
-----------------

The **Endpoint Detector** finds duplicate endpoints and removes or flags them as invalid for the next modules part of the scanner's pipeline.

State Change Detector
---------------------

The **State Change Detector** detects state change in the web app caused by crawling or fuzzing.

State Detector
---------------

The **State Detector** detects duplicate states and collapses them into one.


Detection methods
==================

This section contains all of the detection methods and their functionality.

Basic
-----

.. automodule:: scanner.Detection.Basic.EndpointExtractor
    :members:

.. automodule:: scanner.Detection.Basic.EndpointDetector
    :members:

Clustering Based
----------------

.. note::

    The main idea is to use preimplented clustering algorithms from `Scikit-learn <https://scikit-learn.org/stable/modules/clustering.html>`_
    and `Scikit-learn-extra <https://scikit-learn-extra.readthedocs.io/en/stable/>`_ and implement detection logic around them.

.. warning::

    Currently, the only clustering algorithm available is `DBSCAN <https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html>`_.
    After preliminary evaluation, it showed to be best suited algorithm and the decision was made to use it in the detectors. There is a possibility
    that `the other clustering algorithms <https://scikit-learn.org/stable/modules/clustering.html>`_ could provide better results for specific cases.

    Consider the option of implementing wrappers for the other algorithms and extending the Detectors with the option for algorithm selection.


To cluster data, we need a set of features for a datapoint, which combined together form a cluster. To do this with html data
we have to convert it to a more suitable representation for clustering. Our preprocessing consist of one step. We
hash the html data using a locality sensitive hashing algorithm TLSH, which allows us to use the new data as an input for the algorithms.

The clustering based method internally can be divided into two categories:

Distance Matrix Based
^^^^^^^^^^^^^^^^^^^^^

For this method, the distance d\ :sub:`mn` for all possible hash pairs *(m,n)* is calculated and is presented as a square matrix A.

.. math::
        A = \begin{bmatrix}
                0      & d_{12} & d_{13} & ... & d_{1n} \\
                d_{21} & 0      & d_{23} & ... & d_{2n} \\
                d_{31} & d_{32} & 0      & ... & d_{3n} \\
                .      & .      & .      & .   & .      \\
                .      & .      & .      & .   & .      \\
                .      & .      & .      & .   & .      \\
                d_{m1} & d_{m2} & d_{m3} & ... & 0
            \end{bmatrix}

The distance matrix is then used as an input for the clustering algorithms that can be initialized with a ``metric='precomputed'`` parameter.


Hash as int vector (Hash2Vec)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For this method, hash is represented as a character vector, which subsequently gets transformed into integer vector. This way we can use each character as a numerical feature, and apply the clustering methods directly on the hash set.

.. figure:: img/hash2vec_visualization.png
    :align: center

    *Hash2Vec Visualization*

.. note::

    Additionally, the features are normalized to values between 0 and 1 in the conversion step.

Both categories are implemented in the same classes and are selectable with the ``distance_type`` parameter. If given ``distance_type=None`` as input,
the detectors will use the Hash2Vec method else the distance matrix method is evoked and the given distance type is used for the matrix generation.

.. automodule:: scanner.Detection.ClusteringBased.StateChangeDetector
    :members:

.. automodule:: scanner.Detection.ClusteringBased.EndpointDetector
    :members:

.. automodule:: scanner.Detection.ClusteringBased.StateDetector
    :members:
